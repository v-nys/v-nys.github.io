{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p>This is where I keep a collection of notes related to (for the moment) programming and teaching.</p>"},{"location":"Programming/Rust/Activity%20tracker/Step%201/","title":"What is this and why am I doing it?","text":"<p>I've been working my way through the Rust Book and Rustlings and I'm itching to put my knowledge to the test with a project. Fortunately, I've had this very specific idea for an activity / goal tracking application in my mind for some time now. There are a good number of those, but I think the concept is pretty original and, even if it isn't, it's still about practicing Rust.</p> <p>I know I'm not going to model everything perfectly right away, so I won't even attempt that. Instead, I'd like to post some milestones, explain the reasoning behind how I implemented them and collect feedback in between. So, please, chime in with your thoughts about the code I've written.</p> <p>First, my goals for the final version this tool. This is a wishlist. Some parts may prove difficult or contradictory, but I want to try:</p> <ul> <li>should support a hierarchy of activities, i.e. a tree</li> <li>users should be able to log not just time, but arbitrary metrics</li> <li>users should be able to define goals using these metrics (e.g. A minutes per B days, more than C reps in a session, fewer than D mistakes in an attempt,...)</li> <li>metrics can be associated with leaf nodes and with categories (e.g. E minutes per week spent on some category, with perhaps more specific goals for specific activities within that category)</li> <li>it should be easy for users to add their own metrics without forking the code</li> <li>goals can change over time</li> <li>it should be possible to visualize time spent on activities using a treemap or similar diagram</li> <li>for time-related goals, the tool should be able to indicate how much time the user should spend, or can meaningfully spend, to meet that goal today and potentially in the future (e.g. \"if you have some spare time, you can spend it on X so you won't have to spend as much time on it tomorrow\")</li> <li>it should have a TUI with good auto-completion for easy data entry</li> </ul> <p>That's what I want to implement eventually. But I don't want to overengineer the whole thing. Agile approach, as far as that applies to one-person projects.</p>"},{"location":"Programming/Rust/Activity%20tracker/Step%201/#intent","title":"Intent","text":"<p>I'll start with the tree structure and add in minutes spent on an activity. No other metrics yet and no goals, even for the one metric that is supported. I'll also add serialization and deserialization, but there won't yet be any way to actually apply CRUD operations.</p>"},{"location":"Programming/Rust/Activity%20tracker/Step%201/#implementation","title":"Implementation","text":"<p>My first idea was to do this:</p> <pre><code>classDiagram\n\n  note for Activity \"Serialize,Deserialize\"\n  class Activity {\n    &lt;&lt;struct&gt;&gt;\n      -String description\n  }\n\n  note for Category \"Serialize,Deserialize\"\n  class Category {\n    &lt;&lt;struct&gt;&gt;\n      -String description\n      +Vec&amp;lt;Box&amp;lt;dyn Tracked&amp;gt;&amp;gt; children\n  }\n\n  note for Burst \"Serialize,Deserialize\"\n  class Burst {\n    &lt;&lt;struct&gt;&gt;\n      -chrono::naive::NaiveDate\n      -minutes: usize\n  }\n\n  class Tracked {\n    &lt;&lt;trait&gt;&gt;\n      +get_description() : &amp;String\n  }\n  Activity ..|&gt; Tracked\n  Category ..|&gt; Tracked\n  Burst --&gt; Activity</code></pre> <p>A first bit of skeleton code looks like this:</p> <pre><code>use serde::{Serialize,Deserialize};\n\ntrait Tracked: Serialize + Deserialize {}\n\n#[derive(Serialize,Deserialize)]\nstruct Activity {\ndescription: String\n}\nimpl Tracked for Activity {}\n\n#[derive(Serialize,Deserialize)]\nstruct Category {\ndescription: String,\nchildren: Vec&lt;Box&lt;dyn Tracked&gt;&gt;\n}\nimpl Tracked for Category {}\n\n#[derive(Serialize,Deserialize)]\nstruct Burst {\nminutes: usize,\ndate: chrono::NaiveDate,\n// still need to link to an activity here\n}\n</code></pre> <p>In order to serialize a <code>NaiveDate</code>, we need to use the <code>serde</code> feature from <code>chrono</code>. To derive the serialization functionality, we need the <code>derive</code> feature from <code>serde</code>. So part of my Cargo.toml looks like this:</p> <pre><code>[dependencies]\nchrono = { version = \"0.4.24\", features = [\"serde\"] }\nserde = { version = \"1.0.160\", features = [\"derive\"] }\nserde_json = \"1.0.96\"\n</code></pre> <p>But there is an issue with the code itself, pertaining to deserialization. Specifically, if I try to implement it this way, I get \"error[E0038]: the trait <code>Tracked</code> cannot be made into an object\". This is because it should be deserializable, but it is not <code>Sized</code>. That is, because it's a trait and various structs can implement it, its size cannot be known at compile time.</p> <p>While that isn't the only issue reported here, I'll focus on this first. My first thought was something along the lines of: \"yeah, I'd need to tag each serialized value with its struct name for this to be possible at all\", which led me to consider enums. Then I realized I don't actually want arbitrary implementations of <code>Tracked</code>. It's just a way to group activities and categories anyway and Rust has highly expressive enum types, so that led me to consider the following:</p> <pre><code>classDiagram\n\n  note for Activity \"Serialize,Deserialize\"\n  class Activity {\n    &lt;&lt;struct&gt;&gt;\n      -String description\n  }\n\n  note for Category \"Serialize,Deserialize\"\n  class Category {\n    &lt;&lt;struct&gt;&gt;\n      -String description\n      +Vec&amp;lt;Tracked&amp;gt; children\n  }\n\n  note for Burst \"Serialize,Deserialize\"\n  class Burst {\n    &lt;&lt;struct&gt;&gt;\n      -chrono::naive::NaiveDate\n      -minutes: usize\n  }\n\n  class Tracked {\n    &lt;&lt;enum&gt;&gt;\n      Category(category: Category),\n      Activity(activity: Activity)\n  }\n  Activity -- Tracked\n  Category -- Tracked\n  Burst --&gt; Activity</code></pre> <p>(I don't really know which UML relationship applies here.)</p> <p>Sure enough, this compiles:</p> <pre><code>#[derive(Serialize,Deserialize)]\nenum Tracked {\nAcivity(Activity),\nCategory(Category),\n}\n\n#[derive(Serialize,Deserialize)]\nstruct Activity {\ndescription: String\n}\n\n#[derive(Serialize,Deserialize)]\nstruct Category {\ndescription: String,\nchildren: Vec&lt;Tracked&gt;\n}\n\n#[derive(Serialize,Deserialize)]\nstruct Burst {\nminutes: usize,\ndate: chrono::NaiveDate,\n// would make sense to refer to `Activity` here...\n}\n</code></pre> <p>Now to take care of the association between <code>Activity</code> and <code>Burst</code>. I guess there are two ways to handle this:</p> <ul> <li>an <code>Activity</code> could own any bursts that are associated with it</li> <li>a <code>Burst</code> could reference an activity</li> </ul> <p>For some reason, the latter approach feels more \"right\" to me, but it would be tricky to deserialize. Indeed, adding <code>&amp;'a Activity</code> (and a generic lifetime specifier) to <code>Burst</code> results in a compilation error stating that references to activities don't implement <code>Deserialize&lt;'_&gt;</code>. I could attempt to implement the trait for the reference type, but I don't really have a strong argument for making that effort. Instead, I'll go with the first approach:</p> <pre><code>classDiagram\n\n  note for Activity \"Serialize,Deserialize\"\n  class Activity {\n    &lt;&lt;struct&gt;&gt;\n      -String description\n  }\n\n  note for Category \"Serialize,Deserialize\"\n  class Category {\n    &lt;&lt;struct&gt;&gt;\n      -String description\n      +Vec&amp;lt;Tracked&amp;gt; children\n  }\n\n  note for Burst \"Serialize,Deserialize\"\n  class Burst {\n    &lt;&lt;struct&gt;&gt;\n      -chrono::naive::NaiveDate\n      -minutes: usize\n  }\n\n  class Tracked {\n    &lt;&lt;enum&gt;&gt;\n      Category(category: Category),\n      Activity(activity: Activity)\n  }\n  Activity -- Tracked\n  Category -- Tracked\n  Burst &lt;-- Activity</code></pre> <pre><code>use serde::{Serialize,Deserialize};\n\n#[derive(Serialize,Deserialize)]\nenum Tracked {\nAcivity(Activity),\nCategory(Category),\n}\n\n#[derive(Serialize,Deserialize)]\nstruct Activity {\ndescription: String,\nbursts: Vec&lt;Burst&gt;,\n}\n\n#[derive(Serialize,Deserialize)]\nstruct Category {\ndescription: String,\nchildren: Vec&lt;Tracked&gt;\n}\n\n#[derive(Serialize,Deserialize)]\nstruct Burst {\nminutes: usize,\ndate: chrono::NaiveDate,\n}\n</code></pre> <p>This compiles! It's all just definitions, though, and any functionality that is there is derived. So I don't think I can write meaningful tests. I could add some tests using a specific serialization format, but I'd be testing external crates.</p> <p>Actually, neither <code>Activity</code> nor <code>Category</code> have specific methods, so they don't need their own structs. Although I may change my mind about this later and add them back in, I'll go with this for now:</p> <pre><code>#[derive(Serialize,Deserialize)]\nenum Tracked {\nActivity{\ndescription: String,\nbursts: Vec&lt;Burst&gt;,\n},\nCategory{\ndescription: String,\nchildren: Vec&lt;Tracked&gt;\n},\n}\n#[derive(Serialize,Deserialize)]\nstruct Burst {\ndate: chrono::NaiveDate,\nminutes: usize,\n}\n</code></pre> <p>For the next milestone, I'd like to support some form of data entry. I'm most used to the React model for UI development and I'd like a TUI, so two options appear to be Ratatui with tui-realm and Dioxus. Dioxus has much more support behind it, though, and what I pick up should carry over to non-TUI settings, so I'll probably go with that.</p>"}]}